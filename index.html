<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HNSW Graph Visualization</title>
    <!-- vis.js CDN -->
    <script
      type="text/javascript"
      src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"
    ></script>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        flex-direction: column;
        height: 100vh;
        background-color: #f0f2f5;
      }

      header {
        background-color: #2c3e50;
        color: white;
        padding: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      }

      h1 {
        margin: 0;
        font-size: 1.5rem;
      }

      #controls {
        display: flex;
        gap: 1rem;
        align-items: center;
      }

      button {
        padding: 0.5rem 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
        transition: background-color 0.2s;
      }

      #connectBtn {
        background-color: #27ae60;
        color: white;
      }

      #connectBtn:hover {
        background-color: #219150;
      }

      #connectBtn:disabled {
        background-color: #95a5a6;
        cursor: not-allowed;
      }

      #status {
        font-weight: bold;
        color: #95a5a6;
      }

      #status.connected {
        color: #27ae60;
      }

      #status.disconnected {
        color: #c0392b;
      }

      #main-container {
        display: flex;
        flex: 1;
        overflow: hidden;
      }

      #sidebar {
        width: 300px;
        background-color: white;
        border-right: 1px solid #ddd;
        padding: 1rem;
        overflow-y: auto;
        box-shadow: 2px 0 5px rgba(0, 0, 0, 0.05);
      }

      #stats {
        margin-bottom: 2rem;
      }

      .stat-item {
        display: flex;
        justify-content: space-between;
        margin-bottom: 0.5rem;
        padding-bottom: 0.5rem;
        border-bottom: 1px solid #eee;
      }

      .level-legend {
        display: flex;
        align-items: center;
        margin-bottom: 0.5rem;
      }

      .color-box {
        width: 16px;
        height: 16px;
        margin-right: 8px;
        border-radius: 3px;
      }

      #network {
        flex: 1;
        background-color: #ffffff;
      }

      #log {
        font-family: monospace;
        font-size: 0.8rem;
        color: #666;
        max-height: 200px;
        overflow-y: auto;
        border-top: 1px solid #eee;
        margin-top: 1rem;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>HNSW Graph Visualization</h1>
      <div id="controls">
        <span id="status" class="disconnected">Disconnected</span>
        <button id="connectBtn">Connect & Start</button>
      </div>
    </header>

    <div id="main-container">
      <aside id="sidebar">
        <div id="stats">
          <h3>Statistics</h3>
          <div class="stat-item">
            <span>Total Nodes:</span>
            <span id="nodeCount">0</span>
          </div>
          <div class="stat-item">
            <span>Total Edges:</span>
            <span id="edgeCount">0</span>
          </div>
          <div class="stat-item">
            <span>Max Level:</span>
            <span id="maxLevel">0</span>
          </div>
        </div>

        <div id="legend">
          <h3>Level Legend</h3>
          <!-- Generated by JS -->
        </div>

        <div id="log">
          <div>System ready.</div>
        </div>
      </aside>
      <div id="network"></div>
    </div>

    <script>
      // Configuration
      const WS_URL = "ws://localhost:8080/ws";
      const LEVEL_COLORS = [
        "#4A90E2", // Level 0: Blue
        "#50C878", // Level 1: Green
        "#F5A623", // Level 2: Orange
        "#E24A4A", // Level 3: Red
        "#9B59B6", // Level 4: Purple
        "#34495E", // Level 5+: Dark Blue
      ];

      // State
      let socket = null;
      let nodes, edges, network;
      let nodeCount = 0;
      let edgeCount = 0;
      let maxLevelObserved = 0;

      // DOM Elements
      const connectBtn = document.getElementById("connectBtn");
      const statusEl = document.getElementById("status");
      const nodeCountEl = document.getElementById("nodeCount");
      const edgeCountEl = document.getElementById("edgeCount");
      const maxLevelEl = document.getElementById("maxLevel");
      const logEl = document.getElementById("log");
      const legendEl = document.getElementById("legend");

      // Initialize Visualization
      function initVis() {
        nodes = new vis.DataSet([]);
        edges = new vis.DataSet([]);

        const container = document.getElementById("network");
        const data = { nodes: nodes, edges: edges };
        const options = {
          nodes: {
            shape: "dot",
            font: {
              size: 12,
              face: "Tahoma",
            },
          },
          edges: {
            arrows: {
              to: { enabled: true, scaleFactor: 0.5 },
            },
            smooth: {
              type: "continuous",
            },
            color: {
              color: "#bdc3c7",
              highlight: "#2c3e50",
            },
          },
          physics: {
            enabled: true,
            solver: "forceAtlas2Based",
            forceAtlas2Based: {
              gravitationalConstant: -50,
              centralGravity: 0.01,
              springLength: 100,
              springConstant: 0.08,
            },
            stabilization: {
              enabled: true,
              iterations: 1000,
              updateInterval: 100,
              onlyDynamicEdges: false,
              fit: true,
            },
            maxVelocity: 50,
            minVelocity: 0.1,
            timestep: 0.5,
          },
          layout: {
            randomSeed: 2,
          },
        };

        network = new vis.Network(container, data, options);

        // Add click handler for debugging
        network.on("click", function (params) {
          if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const node = nodes.get(nodeId);
            log(
              `Clicked Node ID: ${nodeId}, Level: ${node.level}, Vector: [${node.title}]`
            );
          }
        });

        generateLegend();
      }

      function generateLegend() {
        legendEl.innerHTML = "<h3>Level Legend</h3>";
        LEVEL_COLORS.forEach((color, index) => {
          const label =
            index === LEVEL_COLORS.length - 1 ? `${index}+` : `${index}`;
          const item = document.createElement("div");
          item.className = "level-legend";
          item.innerHTML = `<div class="color-box" style="background-color: ${color}"></div><span>Level ${label}</span>`;
          legendEl.appendChild(item);
        });
      }

      function getColorForLevel(level) {
        if (level >= LEVEL_COLORS.length) {
          return LEVEL_COLORS[LEVEL_COLORS.length - 1];
        }
        return LEVEL_COLORS[level];
      }

      function getSizeForLevel(level) {
        return 10 + level * 5;
      }

      // WebSocket Logic
      function connect() {
        if (socket && socket.readyState === WebSocket.OPEN) {
          log("Already connected.");
          return;
        }

        connectBtn.disabled = true;
        statusEl.textContent = "Connecting...";

        try {
          socket = new WebSocket(WS_URL);

          socket.onopen = function (e) {
            log("Connection established");
            statusEl.textContent = "Connected";
            statusEl.className = "connected";
            connectBtn.textContent = "Disconnect";
            connectBtn.disabled = false;

            // Send "ok" to start streaming
            socket.send("ok");
            log('Sent "ok" command to server');
          };

          socket.onmessage = function (event) {
            try {
              const data = JSON.parse(event.data);
              handleMessage(data);
            } catch (e) {
              log("Error parsing message: " + e);
              console.error("Raw message:", event.data);
            }
          };

          socket.onclose = function (event) {
            if (event.wasClean) {
              log(
                `Connection closed cleanly, code=${event.code} reason=${event.reason}`
              );
            } else {
              log("Connection died");
            }
            statusEl.textContent = "Disconnected";
            statusEl.className = "disconnected";
            connectBtn.textContent = "Connect & Start";
            connectBtn.disabled = false;
            socket = null;
          };

          socket.onerror = function (error) {
            log(`WebSocket Error: ${error.message || "Unknown error"}`);
          };
        } catch (e) {
          log("Connection failed: " + e);
          connectBtn.disabled = false;
        }
      }

      function disconnect() {
        if (socket) {
          socket.close();
        }
      }

      function handleMessage(msg) {
        // Check message type based on Scala enum structure
        if (msg.NodeAdded) {
          const data = msg.NodeAdded;
          addNode(data.id, data.vector, data.level);
        } else if (msg.NewConnection) {
          const data = msg.NewConnection;
          addEdge(data.fromId, data.toId);
        } else if (msg.result === "ok") {
          log("Server confirmed start.");
        } else {
          console.log("Unknown message format:", msg);
        }
      }

      function addNode(id, vector, level) {
        try {
          // Check if node already exists
          if (!nodes.get(id)) {
            nodes.add({
              id: id,
              label: String(id),
              level: level, // Store level data
              color: getColorForLevel(level),
              size: getSizeForLevel(level),
              title: vector.map((v) => v.toFixed(2)).join(", "), // Tooltip
            });

            nodeCount++;
            nodeCountEl.textContent = nodeCount;

            if (level > maxLevelObserved) {
              maxLevelObserved = level;
              maxLevelEl.textContent = maxLevelObserved;
            }
          }
        } catch (e) {
          console.error("Error adding node:", e);
        }
      }

      function addEdge(fromId, toId) {
        try {
          // Avoid duplicate edges
          const edgeId = `${fromId}-${toId}`;
          if (!edges.get(edgeId)) {
            edges.add({
              id: edgeId,
              from: fromId,
              to: toId,
            });
            edgeCount++;
            edgeCountEl.textContent = edgeCount;
          }
        } catch (e) {
          console.error("Error adding edge:", e);
        }
      }

      function log(message) {
        const div = document.createElement("div");
        div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logEl.insertBefore(div, logEl.firstChild);
        // Limit log size
        if (logEl.children.length > 50) {
          logEl.removeChild(logEl.lastChild);
        }
      }

      // Event Listeners
      connectBtn.addEventListener("click", () => {
        if (
          socket &&
          (socket.readyState === WebSocket.OPEN ||
            socket.readyState === WebSocket.CONNECTING)
        ) {
          disconnect();
        } else {
          // Clear existing graph on new connection
          if (nodeCount > 0) {
            nodes.clear();
            edges.clear();
            nodeCount = 0;
            edgeCount = 0;
            maxLevelObserved = 0;
            updateStats();
          }
          connect();
        }
      });

      function updateStats() {
        nodeCountEl.textContent = nodeCount;
        edgeCountEl.textContent = edgeCount;
        maxLevelEl.textContent = maxLevelObserved;
      }

      // Start
      initVis();
    </script>
  </body>
</html>
